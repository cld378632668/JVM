JVM主要分6个模块。

1、程序计数器（Program Counter Register）

它是线程私有的。线程私有的资源，如这里的内存区域，生命周期与线程相同。


&emsp;&emsp;程序技术器是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的信号指示器。字节码解释器通过改变计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等尤其依赖计数器来完成。

&emsp;

JVM 中不规定任何OutofMemoryError 的模块就是它。

2、JAVA 虚拟机栈（Java VIrtual Machine Stack）
  
  它是线程私有的，描述方法执行的内存模型。每个方法执行时都会同时创建一个栈帧，Stack Frame 存储局部变量表、操作数栈、动态链接、方法出口等信息。方法调用到执行完成的过程对应栈帧在虚拟机栈中从入栈到出栈的过程。


&emsp;

局部变量表：

局部变量表存放了编译器可知的8 种 JAVA基本数据类型，对象引用（reference 类型）和 returnAdresss 类（指向一条字节码指令的地址），其中除64 位长度的 long 和double会占用 2 个局部变量空间(Slot,每个 32 位)其他数据类型占用 1 个 Slot。这部分空间在编译期间完成分配，当进入一个方法时，方法需要在栈帧中分配多大的局部变量空间是确定的，运行期间也不会改变。

&emsp;

JVM 规范对虚拟机栈规定了凉种异常情况：

（1）、 线程请求深度大于 JVM 允许深度，比如递归层数过多，则栈溢出，抛出 StackOverFloweror 异常。

（2）、 虚拟机栈动态扩展无法申请到足够内存，则报 OutOfMemoryError 异常。


&emsp;

方法传递参数时本质是将一个函数对应的栈帧的局部变量表的副本传递（注意是副本不是本身）传递给另一个函数对应的栈帧的局部变量表。

3、本地方法栈（Native Method Stack）

该部分用来支持 Native 方法，一种其他语言编写的可以调用 Java 接口的方法。

JVM 规范本地方法栈规定了两种异常情况：

（1）、 线程请求深度大于 JVM 允许深度，比如递归层数过多，则栈溢出，抛出 StackOverFloweror 异常。

（2）、 虚拟机栈动态扩展无法申请到足够内存，则报 OutOfMemoryError 异常。

4、JAVA堆（JAVA Heap）

它是管理虚拟机内存中最大的一块，所有线程共享，虽 JVM 的启动创建。它的唯一目的是存放对象实例，几乎所有对象的实例都在堆里面分配。

JAVA 堆所处的内存可以是物理不连续的。

JVM 对其规定了 OOMError 异常，如果无法扩展堆的大小来完成新的内存的实例分配时会触发。举个例子（请先看另一篇文章《JVM 的 Heap 堆区》来了解Old、Survivor 等基本概念）， Old 区放满以后会进行 Full GC，若 GC 后 Survivor 及 Old 去仍然无法存放从 Eden 复制过来的部分对象，则 OOM 错误，或者直接存放大对象、大数组，导致老年代空间不足。


5、方法区（Method Area)
    它是线程共享的内存区域，存储已经被 JVM 加载的类信息、常量、静态变量，即编译好后的代码等数据。在 HotSpot中用永久代来实现方法区，其他多数虚拟机不存在永久代。


6、运行时常量池（Runtime Constant Pool，JAVA7 开始从永久代移除放置到Heap中）
