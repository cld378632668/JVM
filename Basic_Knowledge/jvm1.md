新版的JVM主要由四部分组成，分别是 Class Loader、Excution Engine、JVM 内存区 和 Native Method Interface，其中 JVM 内存区由Heap、程序计数器、虚拟机栈、本地方法栈和方法区五部分组成。

# Class Loader 部分的重点是掌握双亲委托机制

Class Loader 顾名思义是 用来加载 Class的，用的是双亲委托机制（这个会在另一篇文章中细讲）。两个类相同，既需要类名相同也需要是被同一个类的加载器加载，否则认为是不同的类。

![Class Loader](../illustration/pig3-9.png)

![Class Loader](https://github.com/cld378632668/JVM/blob/master/illustration/pic3-9.png)


# Excution Engine
这一部分不是面试考查点。在本节我们简单了解下执行引擎即可。详细讲解见另一篇文章。

执行引擎负责解释命令，提交操作系统执行。实现层面，物理机的执行引擎由硬件实现，而虚拟机的执行引擎由自己实现。

JAVA 中编译器将源代码转化成字节码，字节码由执行引擎执行。几乎所有的字节码执行引擎的工作流程都是分三步：1、输入：字节码文件；2、处理：字节码解析；3、输出：执行结果。



# 用顺口溜记住JVM 内存区的组成结构 
    一个堆区（GC堆），4个非堆区：本地方法栈、虚拟机栈、方法区（Java8 HostSpot中称为永久代）、程序计数器

Java堆和方法区是线程共享的， Java虚拟机栈、本地方法栈、程序计数器是线程私有的。可以用顺口溜”虚拟本地方法“来记住虚拟机栈、本地方法栈和方法区三个部分。

共享的是堆和方法区，程序计数器、虚拟机栈和本地方法栈都是私有的。

```
Java堆区结构：
1、新生代（1单位的大小）。含3部分 ： Eden、to Survivor 和from Survivor，他，它们三者的空间大小默认比例是8:1:1。
2、老年代（2个单位的大小）。
3、永久代。
```

新生对象被创建后会首先进入新生代，但是如果是找不到足够连续内存的大对象会直接进入老年代，在15次（通过参数 -XX:MaxTenuringThreshold 来设定）minor GC后仍然存活的对象也会进入老年代，15次GC后可以形象的记为15岁。

有关这部分的更详细和 深入讲解见另一篇文章。

# 本地方法接口支撑 Native 方法

有关这部分的详细讲解见另一篇文章。